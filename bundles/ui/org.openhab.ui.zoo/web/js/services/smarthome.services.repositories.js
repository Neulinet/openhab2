// Generated by CoffeeScript 1.9.2
'use strict';
angular.module('SmartHome.services.repositories', ['SmartHome.services.datacache']).factory('bindingRepository', function(DataCache, bindingService) {
  return DataCache.init(bindingService);
}).factory('thingTypeRepository', function(DataCache, thingTypeService) {
  return DataCache.init(thingTypeService);
}).factory('discoveryResultRepository', function(DataCache, inboxService, eventService) {
  DataCache.init(inboxService);
  eventService.onEvent('smarthome/inbox/added/*', function(topic, discoveryResult) {
    DataCache.add(discoveryResult);
  });
  return DataCache;
}).factory('thingRepository', function(DataCache, thingSetupService) {
  return DataCache.init(thingSetupService);
}).factory('homeGroupRepository', function(DataCache, groupSetupService) {
  return DataCache.init(groupSetupService);
}).factory('itemRepository', function(DataCache, itemService, $log, $q) {
  var GROUP_ROOMS, GROUP_SCENES, ItemRepository;
  GROUP_ROOMS = 'gRooms';
  GROUP_SCENES = 'gScenes';
  return new (ItemRepository = (function() {
    function ItemRepository() {
      this.rooms = {};
      this.itemsActive = [];
      this.allItems = [];
    }

    ItemRepository.prototype.hasTag = function(item, tag) {
      var ref;
      return ((ref = item.tags) != null ? ref.indexOf(tag) : void 0) >= 0;
    };

    ItemRepository.prototype.hasGroup = function(item, group) {
      var ref;
      return ((ref = item.groupNames) != null ? ref.indexOf(group) : void 0) >= 0;
    };

    ItemRepository.prototype.getRooms = function() {
  
      var defered;
      defered = $q.defer();
      itemService.getByName({
        itemName: GROUP_ROOMS
      }, (function(_this) {
        return function(data) {
          var result;
          result = {};
        
          data.members.forEach(function(member) {
            return result[member.name] = member;
          });
          return defered.resolve(result);
        };
      })(this));
      return defered.promise;
    };

    ItemRepository.prototype.getScenes = function() {
      //console.log('in get scene');
      var defered;
      defered = $q.defer();
      itemService.getByTag({
        tags: GROUP_SCENES
      }, function(data) {
        
        var scenes;
       
        scenes = data.map(function(scene) {
         
          //console.log('Scene: ',scene);
          //scene = JSON.parse(scene.state);
         
          var sceneData,sceneError;
          if ((scene.label == 'NULL') || (scene.label == undefined)){
            sceneData = {};
            sceneError =true;
          }else{
            sceneData = JSON.parse(scene.label);;
            sceneError = false;
          }

          return {
            name: scene.name,
            data: sceneData,
            error: sceneError
          };
  
        });
        return defered.resolve(scenes);
      }, function(err) {
        if (err.status === 404) {
          $log.debug("Group for Scenes " + GROUP_SCENES + " did not exist, creating it");
          itemService.create({
            itemName: GROUP_SCENES,
            type: 'GroupItem',
            category: 'scenes',
            groupNames: [],
            tags: []
          }, null, (function(err) {
            return $log.error("Error creating group " + GROUP_SCENES, err);
          }));
          return defered.resolve({
            members: []
          });
        } else {
          $log.error("Error on loading group " + GROUP_SCENES);
          return $log.debug(err);
        }
      });
      return defered.promise;
    };
    
    ItemRepository.prototype.deleteScene = function(sceneName){
      var defered, fnSuccessDeleteScene,fnError;
      defered = $q.defer();

      fnSuccessDeleteScene = function(){
        console.log('Success deleting '+sceneName+' from backend');
        return defered.resolve();
      }
      fnError = function(err){
        console.log(err);
        return defered.reject();
      }
      console.log('getting scene from backend b4 delete');
      itemService.getByName({itemName:sceneName} // get item to make sure it's exist and it's a scene
        ,function(data){
    
          if (data.category == 'scenes'){// makesure it's a scene
            itemService.remove({
              itemName:sceneName
            },fnSuccessDeleteScene,fnError);
          }else{ // not a scene ??
            console.log('error occurs: item with same name as the scene');
            return defered.reject();
          } 
        },function(err){
          if (err.status === 404){
            console.log('This item is not found in the database');
          }
          return defered.reject();
        })
      return defered.promise;
    }

    ItemRepository.prototype.createNewScene = function(name, items) {
      //console.log('In create new scene');
      var defered, fnError, fnSuccessItemCreate, sceneData;
      defered = $q.defer();
      sceneData = items.map(function(item) {
        return {
          name: item.name,
          state: item.state
        };
      });
      console.log('Scene data :',sceneData);
      fnError = function(err) {
         console.log('err putting scene in the backend',err);
        return defered.reject(err);
      };
      fnSuccessItemCreate = function() {
        console.log('Success putting scene in the backend');
        console.log('Scene data in create item:',sceneData);
        return defered.resolve();
      };

      

      itemService.create({
        itemName: name,
        label:JSON.stringify(sceneData),
        type: 'StringItem',
        category: 'scenes',
        tags: [GROUP_SCENES],
        groupNames: [GROUP_SCENES]
       
      }, fnSuccessItemCreate, fnError);
      return defered.promise;
    };

    return ItemRepository;

  })());
});
